import openai

openai.key = ""
def create_completion(
    system_msg: str,
    prompt: str,
    token_used: float,
    name_model: str,
    value_temp,
    request_timeout=180,
    count: int,
    final: int,
):

    # system_msg GPTに提供するsystem roleのメッセージ
    # prompt GPTに提供するuser roleのメッセージ
    # token_used 今まで使ったtokenの数量（k単位）、更新してからreturnする。
    # name_model 使いたいモデルの名前、GPT-3.5,GPT-4,GPT-4-Turboなど
    # value_temp　モデルの温度を設定する値
    # request_timeout responseを待つ時間
    # count 今までのpromptの番号
    # final promptの数量
    
    header = "\r"
    progress = f"{header}Prompt sent {count}/{final}, "

    try:
          response = openai.ChatCompletion.create(
              model=name_model,
              temperature=value_temp,
              request_timeout=request_timeout,
              messages=[
                  {
                      "role": "system",
                      "content": system_msg,
                  },
                  {
                      "role": "user",
                      "content": prompt,
                  },
              ],
          )
        raw_response = response.choices[0].message.content
        token_used += response.usage.total_tokens / 1000

        progress = progress + f"total token usage: {token_used: .2f}K"
        if same_line:
            sys.stdout.flush()
            print(progress, end="")
        else:
            print(progress)
            print(f"generated by {response.model}")
        return raw_response, token_used
    except openai.error.RateLimitError as RLE:
        retry_time = RLE.retry_after if hasattr(RLE, "retry_after") else 2
        logger.info(f"Rate limit exceeded. Retrying in {retry_time} seconds...")
        time.sleep(retry_time)
        return create_completion(
            system_msg,
            prompt,
            token_used,
            name_model,
            value_temp,
            request_timeout,
            count,
            final,
        )
    except openai.error.APIConnectionError as ACE:
        retry_time = 2
        logger.info(f"{ACE}, retry in {retry_time} seconds...")
        time.sleep(retry_time)
        return create_completion(
            system_msg,
            prompt,
            token_used,
            name_model,
            value_temp,
            request_timeout,
            count,
            final,
        )
    except openai.error.APIError as APIE:
        retry_time = 2
        logger.info(f"{APIE}, retry in {retry_time} seconds...")
        time.sleep(retry_time)
        return create_completion(
            system_msg,
            prompt,
            token_used,
            name_model,
            value_temp,
            request_timeout,
            count,
            final,
        )
    except openai.error.Timeout as TOE:
        retry_time = 2
        logger.info(f"{TOE}, retry in {retry_time} seconds...")
        time.sleep(retry_time)
        return create_completion(
            system_msg,
            prompt,
            token_used,
            name_model,
            value_temp,
            request_timeout,
            count,
            final,
        )
